# Serpent

```elixir
my_app_root = Path.join(__DIR__, "graphics")

Mix.install(
  [
    {:graphics, path: my_app_root, env: :dev}
  ],
  # config_path: Path.join(my_app_root, "config/config.exs"),
  lockfile: Path.join(my_app_root, "mix.lock")
)
```

## Game Module

```elixir
import IEx.Helpers
```

```elixir
defmodule Game do
  @segments [{10, 10}, {9, 10}, {8, 10}, {7, 10}, {6, 10}, {5, 10}]
  defstruct serpent: @segments,
            direction: :east,
            apples: [{3, 3}],
            turns: []

  def new(), do: %__MODULE__{}

  def tick(%Game{} = game) do
    game
    |> maybe_turn()
    |> move()
  end

  defp maybe_turn(%Game{turns: []} = game), do: game

  defp maybe_turn(%Game{turns: [next_turn | remaining_turns]} = game) do
    next_game = %Game{game | turns: remaining_turns}
    Game.turn(next_game, next_turn)
  end

  defp serpent_length(), do: Enum.count(@segments)

  def add_turn(%Game{} = game, turn) do
    %Game{game | turns: game.turns ++ [turn]}
  end

  def move(%Game{direction: :east, serpent: [{x, y} | _]} = game),
    do: move_to(game, {rem(x + 1, 20), y})

  def move(%Game{direction: :west, serpent: [{x, y} | _]} = game) do
    x =
      if x < 0,
        do: 20,
        else: x - 1

    move_to(game, {x, y})
  end

  def move(%Game{direction: :north, serpent: [{x, y} | _]} = game) do
    y =
      if y < 0,
        do: 20,
        else: y - 1

    move_to(game, {x, y})
  end

  def move(%Game{direction: :south, serpent: [{x, y} | _]} = game),
    do: move_to(game, {x, rem(y + 1, 20)})

  defp move_to(%Game{} = game, {x, y}) do
    serpent =
      [{x, y} | game.serpent]
      |> Enum.take(serpent_length() - 1)

    %Game{game | serpent: serpent}
  end

  def turn(%Game{direction: :east} = game, :left), do: %Game{game | direction: :north}
  def turn(%Game{direction: :east} = game, :right), do: %Game{game | direction: :south}
  def turn(%Game{direction: :west} = game, :left), do: %Game{game | direction: :south}
  def turn(%Game{direction: :west} = game, :right), do: %Game{game | direction: :north}
  def turn(%Game{direction: :north} = game, :left), do: %Game{game | direction: :west}
  def turn(%Game{direction: :north} = game, :right), do: %Game{game | direction: :east}
  def turn(%Game{direction: :south} = game, :left), do: %Game{game | direction: :east}
  def turn(%Game{direction: :south} = game, :right), do: %Game{game | direction: :west}
  def turn(%Game{direction: :none} = game), do: game

  def render(game, render_fn), do: render_fn.(%{apples: game.apples, segments: game.serpent})
end
```

## User Interface API

```elixir
defmodule Renderer do
  alias Graphics.SVG
  alias Graphics.SVG.Rectangle

  def draw(opts) do
    SVG.new([], 200, 200)
    |> add_rectangles(opts.apples, :red)
    |> add_rectangles(opts.segments, :blue)
    |> SVG.render()
  end

  def add_rectangles(svg, points, color) do
    Enum.reduce(points, svg, fn {_x, _y} = point, acc ->
      add_rectangle(acc, point, color)
    end)
  end

  def add_rectangle(svg, {x, y}, color) do
    SVG.add(
      svg,
      Rectangle.draw(x: (x - 1) * 10, y: (y - 1) * 10, width: 10, height: 10, fill: color)
    )
  end
end
```

```elixir
Renderer.draw(%{apples: [{1, 1}], segments: [{2, 2}, {2, 1}, {2, 3}, {2, 4}]})
```

```elixir
Game.new()
|> Game.move()
|> Game.move()
|> Game.move()
|> Game.render(&Renderer.draw/1)
```

## Kino Animate

```elixir
keyboard = Kino.Control.keyboard([:keydown])
Kino.Control.subscribe(keyboard, :keyboard)

Kino.animate(500, Game.new(), fn _event, game ->
  # doesnÂ´t work, because the keystroke must be received from a different process
  # keystroke = Keyboardhandler.process()

  next_game =
    Game.move(game)
    |> Game.turn(:right)

  frame = Game.render(next_game, &Renderer.draw/1)
  {:cont, frame, next_game}
end)

keyboard
```

```elixir
Game.new()
|> Game.turn(:right)
|> Game.move()
|> Game.render(&Renderer.draw/1)
```

## Keyboard Prototype

```elixir
defmodule Keyboardhandler do
  def process() do
    receive do
      {:keyboard, %{key: "ArrowLeft"}} -> :left
      {:keyboard, %{key: "ArrowRight"}} -> :right
    after
      1 -> :none
    end
  end
end
```

```elixir
keyboard = Kino.Control.keyboard([:keydown])
Kino.Control.subscribe(keyboard, :keyboard)

keyboard
```

```elixir
Kino.Control.subscribe(keyboard, keyboard)

Keyboardhandler.process()
```

## OTP Server

Create OTP game server with CRC

- construct: `init` that takes a frame, create a game, render the game, start a timer to: `move`
- reduce: `handle_call` to `move` and `handle_cast` to `turn`
- convert: part of `handle_call` to `render` the `game`

```elixir
defmodule Server do
  use GenServer

  def init({frame, game_keyboard}) do
    Kino.Control.subscribe(game_keyboard, :keyboard)

    game = Game.new()
    render(frame, game)
    :timer.send_interval(250, :game, :move)
    {:ok, {frame, game}}
  end

  def render(frame, %Game{} = game) do
    svg = Game.render(game, &Renderer.draw/1)
    Kino.Frame.render(frame, svg)
  end

  def handle_info(:move, {frame, %Game{} = game}) do
    next_game = Game.tick(game)
    render(frame, next_game)
    {:noreply, {frame, next_game}}
  end

  def handle_info({:keyboard, %{key: "ArrowRight"}}, {frame, %Game{} = game}) do
    {:noreply, {frame, Game.add_turn(game, :right)}}
  end

  def handle_info({:keyboard, %{key: "ArrowLeft"}}, {frame, %Game{} = game}) do
    {:noreply, {frame, Game.add_turn(game, :left)}}
  end

  def handle_info({:keyboard, _other_key}, {frame, %Game{} = game}) do
    {:noreply, {frame, game}}
  end

  def start_link(frame, game_keyboard) do
    GenServer.start(__MODULE__, {frame, game_keyboard}, name: :game)
  end

  def go(game_keyboard) do
    frame = Kino.Frame.new()
    {:ok, _pid} = start_link(frame, game_keyboard)
    frame
  end
end
```

## Kill Server

```elixir
:game
|> GenServer.whereis()
|> Process.exit(:unscheduled)
```

## Run Server

```elixir
keyboard = Kino.Control.keyboard([:keydown])
```

```elixir
Server.go(keyboard)
```

```elixir

```
